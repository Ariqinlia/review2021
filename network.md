# get和post区别
从语义上来讲：
1.get就是用来获取数据，post就是提交数据
2.get参数有长度限制（受限于URL的长度），而post无限制
3.get请求数据会附加在URL上，以?来分割URL和传递的数据，多个参数用&连接，而post请求时会把请求的数据放在http请求体中
4.get请求是明文传输，post是放在请求体中
5.get请求会保存在浏览器历史记录中，还可能保存在web服务器中
以上可以看出post相对get来说会更安全
但是其实本质上get和post都是TCP连接，由于http协议和浏览器或者服务器的限制，从而使它们在应用过程中产生了差别。
有个较大的区别：
- [get在请求时发送一个数据包]，会将header和data一起发过去
- [post会产生两个数据包]，先发送header，服务器返回100，再发送data，服务器返回200
get是请求获取指定资源，get方法时安全(相对服务器安全，没有引起服务器任何变化)、幂等(同一个请求执行多次和一次效果是完全相同的)、可缓存的，get方法的报文主体没有任何语义。
post是根据报文主体来对指定资源做出处理，post不安全，不幂等，不可缓存（大部分情况下）。

# 前端的存储方式
[cookie]：是服务器发送到浏览器并保存在本地的一小块数据，会在浏览器下次向同一服务器发起请求时被携带并发送到服务器上。
- 通常，它用于告知服务器两个请求是否来自同一浏览器，如保持用户的登录状态
主要用于一下三方面：
- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）
- 浏览器行为追踪（如跟踪分析用户行为等）
特点：
- cookie大小受限，一般为4kb
- 同一个域名下存放cookie的个数是有限制的，不同浏览器个数不一样，一般为20个
- cookie支持设置过期时间，过期时自动销毁
- 每次发起同域下的HTTP请求时，都会携带当前域名下的cookie
- 支持设置为HttpOnly,防止cookie被客户端的JavaScript访问
[sessionStorage]：与服务器端的session类似，sessionStorage是一种[会话级别]的缓存，[关闭浏览器时数据会被清除]。sessionstorage的作用域是窗口级别的，也就是说[不同窗口之间保存的数据不能共享]
特点：
- 数据只存在于当前浏览器的标签页
- 数据在页面刷新后依然存在，但关闭浏览器标签页就会被清除
- 与localstorage拥有统一的api接口
- 对数据的操作时同步的
[localStorage]：一种[持久化]的存储方式，如果[不手动清除]，[数据永远不会过期]。采用键值对的存储方式，按域名将数据分别保存到对应的数据库文件里
特点：
- 大小限制为5MB~10MB
- 在同源的所有标签页和窗口之间共享数据
- 数据仅保存在客户端，不与服务器进行通信
- 数据持久存在且不过期，重启浏览器依旧存在
- 对数据的操作是同步的
[WebSQL]：引入了一组API来使用SQL来操作客户端数据库。HTML5已经放弃Web SQL数据库。
[indexedDB]：indexedDB是一种底层api，用于[客户端存储大量结构化数据]，包括文件、二进制大型对象。该api使用索引来实现对该数据的高性能搜索
- 存储空间大：存储空间可以达到几百兆甚至更多
- 支持二进制存储
- indexedDB又同源限制，每一个数据库只能在自身域名下能访问，不能跨域名访问
- 支持事务型：执行的操作根据事务来分组，在一个事务中，要么所有操作都成功，要么都失败
- 键值对存储
- 数据操作是异步的

# HTTP缓存
[强缓存]：在已有缓存数据时，浏览器先向缓存数据库中发起请求数据，缓存数据库会检查是否失效，如果没失效，直接返回缓存数据；如果失效，服务器会向服务器请求数据，服务器返回数据和缓存规则，客户端再将数据和规则存入缓存数据库。
- 请求时间小于服务器返回的到期时间，直接使用缓存数据
- [Cache-Control]：private(客户端可以缓存，默认),public(客户端&代理服务器),max-age=xxx(缓存的内容到期时间),no-cache,no-store
[协商缓存]：在已有缓存数据时，浏览器先向缓存数据库获取缓存数据标识，缓存数据库会返回是否失效标识，无论是否失效都要去请求服务器，验证数据是否失效，如果没失效，通知客户端没失效，重新去缓存数据库中请求数据；如果失效，服务器会返回最新的缓存数据和规则，客户端再存入缓存数据库。
- 服务器在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存
- 将缓存信息中的Etag和last-modified通过请求发送给服务器，服务区校验返回304，浏览器就可以直接使用缓存
简言之：强缓存只要有有效的数据，就不用再去请求服务器；协商缓存不管是否有效，都要去请求服务器，如果失效了就直接返回最新的缓存数据和规则，反之，客户端就去缓存数据库中获取数据。

# 跨域（非同源策略请求）
协议，域名和端口号，三个都相同是同源策略，只要有一个不同就是跨域
- 同源策略请求：ajax / fetch
- 跨域传输
[JSONP]：script,img,link,iframe不存在跨域的限制。
- 客户端向服务器发送请求，同时会把本地的一个函数传递给服务器
- 服务器接收到请求，拿到callback，先准备JSON格式的数据data={...}，再给客户端返回数据"func(JSON.stringify(data))"
- 只能用get请求
[CORS跨域资源共享]：需要浏览器和服务端同时支持，实现CORS的关键是后端
- 简单请求：
（1）请求方法为其一：HEAD、GET、POST
（2）HTTP的请求头信息不超出以下几种字段：
- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于application/x-www-form-urlencoded、multipart/form-data、text/plain
（3）后端的响应头信息：
- Access-Control-Allow-Origin：必选，它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。
- Access-Control-Allow-Credentials：可选，它的值是一个布尔值，表示是否允许发送Cookie。
- Access-Control-Expose-Headers：可选，CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。
- 非简单请求(复杂请求)：不符合以上条件就是复杂请求。复杂的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为[预检]请求，OPTION请求不做任何处理
- 客户端发送Ajax/fetch请求
- 服务器端设置相关的头信息
- Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。
- Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。
[proxy]：webpack-dev-server中的proxy，设置代理
[Ngnix反向代理]：
[postMessage]：
[WebSocket]：是一种双向通信协议，在建立连接之后，WebSocket的server与client都能主动向对方发送或接收数据

# 浏览器渲染过程
- 解析HTML生成DOM树
- 解析CSS生成CSSOM规则树
- 将DOM树和CSSOM规则树合并，生成渲染树
- 遍历渲染树，开始布局，计算每个节点的位置大小信息
- 将渲染树每个节点绘制到屏幕并显示
[构建DOM树]：当浏览器收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞
[构建CSSOM树]：浏览器解析CSS文件并生成CSS规则树，每个CSS文件都会被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象对应于CSS语法的选择器和声明对象以及其他对象
[渲染阻塞]：当浏览器遇到一个script标记时，DOM构建会暂停，直到脚本执行完成再继续。如果脚本操作了CSS，会先构建CSS，再执行脚本。
           所以应该先引入CSS文件，再把js文件放到页面底部，尽量不影响DOM的构建。
           浏览器查找样式是从右到左的顺序匹配的，例如div p {color:red;}，就会先找到所有的p标签，再判断是否有div是父元素。所有尽量用id和class，不要过渡重叠
[构建渲染树]：通过DOM树和CSS规则树就可以构建渲染树。会从DOM树的根节点开始遍历可见节点，并找到匹配的CSS规则来应用。
             渲染树是用于显示，只显示可见的节点
[渲染树布局]：布局阶段会从渲染树的根节点开始遍历，确定每个节点具体位置大小，布局阶段输出的是一个盒子模型，会精确捕获每个元素在屏幕中的确切位置和大小
[渲染树绘制]：绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕中显示内容。其绘制工作是由浏览器的UI后端组件完成的
## 重绘(repaint)与回流(reflow)
[重绘repaint]：屏幕的一部分变了，但不影响整体布局，元素的大小和位置没发生变化，这时就会触发重绘
[回流reflow]：元素大小或者位置变了，需要重新验证并计算渲染树，就会触发回流
---------------
回流更消耗性能，回流一定会触发重绘，而重绘不一定会触发回流
---------------
display: none;不在文档流中占用空间，会触发回流
visibility: hidden;属于隐藏属性，在文档流中占有位置，所以会触发重绘
## 避免DOM的回流
- 减少对DOM的操作，使用vue/react/angular，利用数据影响视图的模式来构建项目
- 分离读写操作（现代浏览器的渲染队列机制）：遇到一个改变样式的代码，就放入渲染队列中，再执行下一段代码，如果依然是改变样式的，也放入渲染队列中，直到下一段代码不是改变样式的，然后将渲染队列中的所有代码拿出来渲染到页面上就，这时就只会触发一次回流，而老版本的浏览器就是只要改变了样式就立即回流
- 样式集中改变：把样式先写好，再通过修改类来实现样式集中
- 缓存布局信息：把要操作的内容一次拿到，用变量存储，要设置的时候直接拿到，避免多次获取
- 元素批量修改：可以采用文档碎片的方法，把新创建的元素先放入一个变量中，等全部创建完毕再统一增加到页面中进行渲染
- 脱离文档流：也会引起回流和重绘，只不过是脱离了文档流，重新计算的过程会比较快一点
- CSS硬件加速（GPU加速）：比起减少回流和重绘，更期望的是不要回流重绘，transform/opacity/filters...这些属性会触发硬件加速，不会引发回流和重绘
- 牺牲平滑度来换取速度
- 避免table布局和使用CSS的JavaScript表达式

# 浏览器中输入URL发生了什么
- DNS域名解析，拿到对应的IP地址
- 建立TCP请求，三次握手建立连接，客户端->服务器->客户端
- 发送HTTP请求
- 服务器处理请求
- 返回响应结果
- 关闭TCP连接
- 浏览器解析HTML
- 浏览器布局渲染
当我们在浏览器中输入网址并回车后，将会发生
[DNS域名解析]：在浏览器输入网址，其实就是向服务器发起请求。所有浏览器首先要确认域名对应的服务器在哪里，这就由DNS服务器来解析对应的IP地址
[建立TCP请求]：客户端向服务端发起连接请求，服务端收到之后并返回一个确认信息给客户端，客户端再回传一个数据包，代表握手结束，连接成功
[发送HTTP请求]：与服务器连接成功之后，就可以向服务器发起HTTP请求了，请求报文
[服务器处理请求]：服务器收到请求后，由web服务器(HTTP服务器)处理请求。web服务器解析用户请求，最后将结果通过web服务器返回给浏览器客户端
[返回响应结果]：在响应结果中都会有一个HTTP状态码，可以通过这个状态码知道服务器的处理是否正常
[关闭TCP连接]：当双方没有请求或响应传递时，任意一方都可以发起关闭请求，这次需要4次握手。客户端->服务器->服务器->客户端
[浏览器解析HTML]：浏览器解析HTML生成DOM树，解析CSS生成CSS规则树，再合并到一起生成渲染树
[浏览器布局渲染]：根据渲染树的布局，计算每个节点在页面的大小和位置，并绘制。